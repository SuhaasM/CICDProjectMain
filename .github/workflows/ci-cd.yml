name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 21
      uses: actions/setup-java@v3
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Build and Test Backend
      run: |
        cd backend
        chmod +x mvnw
        ./mvnw clean package
        
    - name: Set up Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
        
    - name: Build Frontend
      run: |
        cd frontend
        npm install
        npm run build
        
    - name: Login to Docker Hub
      if: github.ref == 'refs/heads/main'
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKER_HUB_USERNAME }}
        password: ${{ secrets.DOCKER_HUB_TOKEN }}
        
    - name: Build and Push Docker Images
      if: github.ref == 'refs/heads/main'
      run: |
        docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-backend:latest ./backend
        docker build -t ${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-frontend:latest ./frontend
        docker push ${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-backend:latest
        docker push ${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-frontend:latest
        
  deploy:
    needs: build-and-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
        
    - name: Deploy to AWS EC2 (SSH or SSM)
      run: |
        set -euo pipefail
        echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
        chmod 600 private_key.pem
        cat > deploy-remote.sh <<'SCRIPT'
        set -euxo pipefail
        if ! command -v docker &> /dev/null; then
          sudo dnf install docker -y
          sudo systemctl start docker
          sudo systemctl enable docker
          sudo usermod -a -G docker $USER
        fi
        if docker compose version > /dev/null 2>&1; then
          COMPOSE_CMD="sudo docker compose"
        elif command -v docker-compose > /dev/null 2>&1; then
          COMPOSE_CMD="sudo docker-compose"
        else
          sudo dnf install -y docker-compose-plugin || true
          if docker compose version > /dev/null 2>&1; then
            COMPOSE_CMD="sudo docker compose"
          else
            sudo dnf install -y curl
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.18.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            COMPOSE_CMD="sudo /usr/local/bin/docker-compose"
          fi
        fi
        echo "${{ secrets.DOCKER_HUB_TOKEN }}" | sudo docker login -u "${{ secrets.DOCKER_HUB_USERNAME }}" --password-stdin
        sudo docker pull "${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-backend:latest"
        sudo docker pull "${{ secrets.DOCKER_HUB_USERNAME }}/cicdproject-frontend:latest"
        export DOCKER_HUB_USERNAME="${{ secrets.DOCKER_HUB_USERNAME }}"
        $COMPOSE_CMD down || true
        $COMPOSE_CMD up -d
        SCRIPT
        SSH_OK=0
        ssh -o BatchMode=yes -o StrictHostKeyChecking=no -o ConnectTimeout=10 -i private_key.pem -p 22 ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'echo ok' && SSH_OK=1 || true
        if [ "$SSH_OK" = "1" ]; then
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i private_key.pem -P 22 docker-compose.yml ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 -i private_key.pem -P 22 deploy-remote.sh ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }}:~/
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ConnectionAttempts=3 -o ServerAliveInterval=15 -o ServerAliveCountMax=2 -i private_key.pem -p 22 ${{ secrets.EC2_USERNAME }}@${{ secrets.EC2_HOST }} 'bash ~/deploy-remote.sh'
        else
          echo "SSH unreachable; using AWS SSM"
          INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=ip-address,Values=${{ secrets.EC2_HOST }}" --query 'Reservations[].Instances[].InstanceId' --output text)
          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID=$(aws ec2 describe-instances --filters "Name=private-ip-address,Values=${{ secrets.EC2_HOST }}" --query 'Reservations[].Instances[].InstanceId' --output text)
          fi
          test -n "$INSTANCE_ID"
          CONTENT=$(base64 -w 0 docker-compose.yml)
          SCRIPT_B64=$(base64 -w 0 deploy-remote.sh)
          CMD_ID=$(aws ssm send-command --document-name 'AWS-RunShellScript' --instance-ids "$INSTANCE_ID" --comment 'Deploy CICDProjectMain' --parameters commands="[\"set -euxo pipefail\",\"echo $CONTENT | base64 -d > docker-compose.yml\",\"echo $SCRIPT_B64 | base64 -d > deploy-remote.sh\",\"bash ./deploy-remote.sh\"]" --query 'Command.CommandId' --output text)
          for i in $(seq 1 20); do
            STATUS=$(aws ssm get-command-invocation --command-id "$CMD_ID" --instance-id "$INSTANCE_ID" --query 'Status' --output text || echo 'Unknown')
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then break; fi
            if [ "$STATUS" = "Failed" ] || [ "$STATUS" = "Cancelled" ] || [ "$STATUS" = "TimedOut" ]; then exit 1; fi
            sleep 10
          done
        fi
        rm -f private_key.pem deploy-remote.sh

  deploy-k8s:
    needs: [build-and-test, deploy]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      - name: Install Ansible and OpenSSH client
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible openssh-client
      - name: Write SSH key
        run: |
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > private_key.pem
          chmod 600 private_key.pem
      - name: Add EC2 host to known_hosts
        run: |
          mkdir -p "$HOME/.ssh"
          ssh-keyscan -T 30 -H ${{ secrets.EC2_HOST }} >> "$HOME/.ssh/known_hosts"
      - name: Deploy to remote k3s with Ansible
        env:
          DOCKER_HUB_USERNAME: ${{ secrets.DOCKER_HUB_USERNAME }}
          ANSIBLE_HOST_KEY_CHECKING: "false"
        run: |
          ansible-playbook -i "${{ secrets.EC2_HOST }}," -u ${{ secrets.EC2_USERNAME }} --private-key private_key.pem \
            -e dockerhub_username=${DOCKER_HUB_USERNAME} -e image_tag=latest \
            ansible/deploy_k8s.yml
      - name: Cleanup
        run: rm -f private_key.pem
